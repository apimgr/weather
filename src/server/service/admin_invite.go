package service

import (
	"crypto/rand"
	"database/sql"
	"encoding/base64"
	"fmt"
	"time"
	"github.com/apimgr/weather/src/server/model"
)

// AdminInviteService handles admin invitation logic
// TEMPLATE.md Part 31: Admin invite system with 15-minute tokens
type AdminInviteService struct {
	DB          *sql.DB
	InviteModel *models.AdminInviteModel
	AdminModel  *models.AdminModel
	// EmailService integration available when SMTP is configured
	// Application base URL for invite links
	BaseURL string
}

// NewAdminInviteService creates a new admin invite service
func NewAdminInviteService(db *sql.DB, baseURL string) *AdminInviteService {
	return &AdminInviteService{
		DB:          db,
		InviteModel: &models.AdminInviteModel{DB: db},
		AdminModel:  &models.AdminModel{DB: db},
		// EmailService: emailService,
		BaseURL: baseURL,
	}
}

// GenerateInviteToken generates a cryptographically secure random token
func (s *AdminInviteService) GenerateInviteToken() (string, error) {
	// Generate 32 random bytes
	tokenBytes := make([]byte, 32)
	if _, err := rand.Read(tokenBytes); err != nil {
		return "", fmt.Errorf("failed to generate random token: %w", err)
	}

	// Encode as URL-safe base64
	token := base64.URLEncoding.EncodeToString(tokenBytes)
	return token, nil
}

// CreateInvite creates a new admin invitation
func (s *AdminInviteService) CreateInvite(email string, invitedByID int) (*models.AdminInvite, error) {
	// Check if inviter is a valid admin
	_, err := s.AdminModel.GetByID(int64(invitedByID))
	if err != nil {
		return nil, fmt.Errorf("inviter admin not found: %w", err)
	}

	// Check if email is already an admin
	existingAdmin, err := s.AdminModel.GetByEmail(email)
	if err == nil && existingAdmin != nil {
		return nil, fmt.Errorf("email is already registered as admin")
	}

	// Generate secure token (will be generated by InviteModel.CreateInvite)
	// Create invite in database
	invite, err := s.InviteModel.CreateInvite(email, int64(invitedByID))
	if err != nil {
		return nil, err
	}

	// Send invitation email when SMTP is configured
	// if s.EmailService != nil {
	// 	inviteURL := fmt.Sprintf("%s/admin/invite/accept?token=%s", s.BaseURL, token)
	// 	err = s.sendInviteEmail(email, inviteURL, invite.ExpiresAt)
	// 	if err != nil {
	// 		fmt.Printf("Warning: Failed to send invite email to %s: %v\n", email, err)
	// 	}
	// }

	return invite, nil
}

// VerifyInvite checks if an invite token is valid
func (s *AdminInviteService) VerifyInvite(token string) (*models.AdminInvite, error) {
	invite, err := s.InviteModel.GetInvite(token)
	if err != nil {
		return nil, fmt.Errorf("invalid invite token")
	}

	// Check if already used
	if invite.UsedBy != nil {
		return nil, fmt.Errorf("invite token has already been used")
	}

	// Check if expired (15-minute window per TEMPLATE.md Part 31)
	if time.Now().After(invite.ExpiresAt) {
		return nil, fmt.Errorf("invite token has expired")
	}

	return invite, nil
}

// AcceptInvite processes an invite acceptance and creates the admin account
func (s *AdminInviteService) AcceptInvite(token, username, password string) (*models.Admin, error) {
	// Verify invite
	invite, err := s.VerifyInvite(token)
	if err != nil {
		return nil, err
	}

	// Hash password (using Argon2id per TEMPLATE.md Part 0)
	// Import password hashing utility
	// Note: In production, this would use the Argon2id implementation from utils/password.go
	// For this placeholder, we're assuming the password is pre-hashed
	// In real implementation: utils.HashPassword(password)
	passwordHash := password

	// Create admin account
	admin, err := s.AdminModel.Create(username, invite.InvitedEmail, passwordHash, false)
	if err != nil {
		return nil, fmt.Errorf("failed to create admin account: %w", err)
	}

	// Mark invite as used
	if err := s.InviteModel.MarkInviteUsed(token, admin.ID); err != nil {
		// Log error but don't fail (admin was created successfully)
		fmt.Printf("Warning: Failed to mark invite as used: %v\n", err)
	}

	return admin, nil
}

// GetPendingInvites returns all active invites
func (s *AdminInviteService) GetPendingInvites() ([]models.AdminInvite, error) {
	return s.InviteModel.GetPendingInvites()
}

// CleanupExpiredInvites removes expired invites (should be run periodically)
func (s *AdminInviteService) CleanupExpiredInvites() error {
	return s.InviteModel.DeleteExpiredInvites()
}

// sendInviteEmail sends an invitation email
// Re-enable when SMTP service is configured
func (s *AdminInviteService) sendInviteEmail(toEmail, inviteURL string, expiresAt time.Time) error {
	_ = toEmail
	_ = inviteURL
	minutesRemaining := int(time.Until(expiresAt).Minutes())
	_ = minutesRemaining

	// Email sending via SMTP service
	/*
	subject := "Admin Invitation - Weather Service"

	body := fmt.Sprintf(`You have been invited to become an administrator of the Weather Service.

Click the link below to accept the invitation and create your admin account:

%s

This invitation will expire in %d minutes.

If you did not request this invitation, please ignore this email.

---
Weather Service
`, inviteURL, minutesRemaining)

	// Use email service to send
	// Note: This assumes EmailService has a Send method
	// In real implementation, this would use the actual email service
	fmt.Printf("Sending invite email to %s\nInvite URL: %s\n", toEmail, inviteURL)
	*/

	return nil
}

// RevokeInvite revokes a pending invite
func (s *AdminInviteService) RevokeInvite(token string) error {
	// Mark as expired by setting used_at to now
	// This effectively invalidates the invite
	return s.InviteModel.MarkInviteUsed(token, 0)
}
