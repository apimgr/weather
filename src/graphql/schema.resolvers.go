package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.60

import (
	"context"
	"fmt"
	"time"

	"github.com/apimgr/weather/src/server/model"
	"github.com/apimgr/weather/src/utils"
)

// ExpiresAt is the resolver for the expiresAt field.
func (r *aPITokenResolver) ExpiresAt(ctx context.Context, obj *models.APIToken) (*time.Time, error) {
	if obj.ExpiresAt.Valid {
		return &obj.ExpiresAt.Time, nil
	}
	return nil, nil
}

// LastUsedIP is the resolver for the lastUsedIP field.
func (r *aPITokenResolver) LastUsedIP(ctx context.Context, obj *models.APIToken) (*string, error) {
	if obj.LastUsedIP.Valid {
		return &obj.LastUsedIP.String, nil
	}
	return nil, nil
}

// UpdateUserProfile is the resolver for the updateUserProfile field.
func (r *mutationResolver) UpdateUserProfile(ctx context.Context, displayName *string, phone *string) (*models.User, error) {
	// Get user from context
	userID, ok := ctx.Value("user_id").(int64)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	// Update user in database
	if displayName != nil {
		_, err := r.ServerDB.Exec("UPDATE users SET display_name = ?, updated_at = ? WHERE id = ?", *displayName, time.Now(), userID)
		if err != nil {
			return nil, fmt.Errorf("failed to update display name: %w", err)
		}
	}

	if phone != nil {
		_, err := r.ServerDB.Exec("UPDATE users SET phone = ?, updated_at = ? WHERE id = ?", *phone, time.Now(), userID)
		if err != nil {
			return nil, fmt.Errorf("failed to update phone: %w", err)
		}
	}

	// Fetch updated user
	user := &models.User{}
	err := r.ServerDB.QueryRow("SELECT id, username, email, display_name, phone, role, is_active, email_verified, created_at, updated_at FROM users WHERE id = ?", userID).Scan(
		&user.ID, &user.Username, &user.Email, &user.DisplayName, &user.Phone, &user.Role, &user.IsActive, &user.EmailVerified, &user.CreatedAt, &user.UpdatedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch user: %w", err)
	}

	return user, nil
}

// CreateSavedLocation is the resolver for the createSavedLocation field.
func (r *mutationResolver) CreateSavedLocation(ctx context.Context, name string, lat float64, lon float64, country *string, region *string, alerts *bool) (*models.SavedLocation, error) {
	userID, ok := ctx.Value("user_id").(int64)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	alertsEnabled := true
	if alerts != nil {
		alertsEnabled = *alerts
	}

	timezone := ""
	result, err := r.ServerDB.Exec(`
		INSERT INTO saved_locations (user_id, name, latitude, longitude, timezone, alerts_enabled, created_at, updated_at)
		VALUES (?, ?, ?, ?, ?, ?, ?, ?)
	`, userID, name, lat, lon, timezone, alertsEnabled, time.Now(), time.Now())

	if err != nil {
		return nil, fmt.Errorf("failed to create location: %w", err)
	}

	id, err := result.LastInsertId()
	if err != nil {
		return nil, err
	}

	location := &models.SavedLocation{}
	err = r.ServerDB.QueryRow(`
		SELECT id, user_id, name, latitude, longitude, timezone, alerts_enabled, created_at, updated_at
		FROM saved_locations WHERE id = ?
	`, id).Scan(&location.ID, &location.UserID, &location.Name, &location.Latitude, &location.Longitude, &location.Timezone, &location.AlertsEnabled, &location.CreatedAt, &location.UpdatedAt)

	if err != nil {
		return nil, fmt.Errorf("failed to fetch location: %w", err)
	}

	return location, nil
}

// UpdateSavedLocation is the resolver for the updateSavedLocation field.
func (r *mutationResolver) UpdateSavedLocation(ctx context.Context, id string, name *string, alerts *bool) (*models.SavedLocation, error) {
	userID, ok := ctx.Value("user_id").(int64)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	if name != nil {
		_, err := r.ServerDB.Exec("UPDATE saved_locations SET name = ?, updated_at = ? WHERE id = ? AND user_id = ?", *name, time.Now(), id, userID)
		if err != nil {
			return nil, fmt.Errorf("failed to update name: %w", err)
		}
	}

	if alerts != nil {
		_, err := r.ServerDB.Exec("UPDATE saved_locations SET alerts_enabled = ?, updated_at = ? WHERE id = ? AND user_id = ?", *alerts, time.Now(), id, userID)
		if err != nil {
			return nil, fmt.Errorf("failed to update alerts: %w", err)
		}
	}

	location := &models.SavedLocation{}
	err := r.ServerDB.QueryRow(`
		SELECT id, user_id, name, latitude, longitude, timezone, alerts_enabled, created_at, updated_at
		FROM saved_locations WHERE id = ? AND user_id = ?
	`, id, userID).Scan(&location.ID, &location.UserID, &location.Name, &location.Latitude, &location.Longitude, &location.Timezone, &location.AlertsEnabled, &location.CreatedAt, &location.UpdatedAt)

	if err != nil {
		return nil, fmt.Errorf("failed to fetch location: %w", err)
	}

	return location, nil
}

// DeleteSavedLocation is the resolver for the deleteSavedLocation field.
func (r *mutationResolver) DeleteSavedLocation(ctx context.Context, id string) (*GenericResponse, error) {
	userID, ok := ctx.Value("user_id").(int64)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	result, err := r.ServerDB.Exec("DELETE FROM saved_locations WHERE id = ? AND user_id = ?", id, userID)
	if err != nil {
		return &GenericResponse{Success: false, Message: fmt.Sprintf("Failed to delete location: %v", err)}, nil
	}

	rows, _ := result.RowsAffected()
	if rows == 0 {
		return &GenericResponse{Success: false, Message: "Location not found"}, nil
	}

	return &GenericResponse{Success: true, Message: "Location deleted successfully"}, nil
}

// ToggleLocationAlerts is the resolver for the toggleLocationAlerts field.
func (r *mutationResolver) ToggleLocationAlerts(ctx context.Context, id string) (*models.SavedLocation, error) {
	userID, ok := ctx.Value("user_id").(int64)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	_, err := r.ServerDB.Exec(`
		UPDATE saved_locations 
		SET alerts_enabled = NOT alerts_enabled, updated_at = ? 
		WHERE id = ? AND user_id = ?
	`, time.Now(), id, userID)

	if err != nil {
		return nil, fmt.Errorf("failed to toggle alerts: %w", err)
	}

	location := &models.SavedLocation{}
	err = r.ServerDB.QueryRow(`
		SELECT id, user_id, name, latitude, longitude, timezone, alerts_enabled, created_at, updated_at
		FROM saved_locations WHERE id = ? AND user_id = ?
	`, id, userID).Scan(&location.ID, &location.UserID, &location.Name, &location.Latitude, &location.Longitude, &location.Timezone, &location.AlertsEnabled, &location.CreatedAt, &location.UpdatedAt)

	if err != nil {
		return nil, fmt.Errorf("failed to fetch location: %w", err)
	}

	return location, nil
}

// MarkNotificationRead is the resolver for the markNotificationRead field.
func (r *mutationResolver) MarkNotificationRead(ctx context.Context, id string) (*models.Notification, error) {
	userID, ok := ctx.Value("user_id").(int64)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	_, err := r.ServerDB.Exec(`
		UPDATE user_notifications 
		SET is_read = 1, read_at = ?, updated_at = ? 
		WHERE id = ? AND user_id = ?
	`, time.Now(), time.Now(), id, userID)

	if err != nil {
		return nil, fmt.Errorf("failed to mark notification as read: %w", err)
	}

	notification := &models.Notification{}
	err = r.ServerDB.QueryRow(`
		SELECT id, user_id, type, title, message, is_read, read_at, created_at, updated_at
		FROM user_notifications WHERE id = ? AND user_id = ?
	`, id, userID).Scan(&notification.ID, &notification.UserID, &notification.Type, &notification.Title, &notification.Message, &notification.IsRead, &notification.ReadAt, &notification.CreatedAt, &notification.UpdatedAt)

	if err != nil {
		return nil, fmt.Errorf("failed to fetch notification: %w", err)
	}

	return notification, nil
}

// MarkAllNotificationsRead is the resolver for the markAllNotificationsRead field.
func (r *mutationResolver) MarkAllNotificationsRead(ctx context.Context) (*GenericResponse, error) {
	userID, ok := ctx.Value("user_id").(int64)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	_, err := r.ServerDB.Exec(`
		UPDATE user_notifications 
		SET is_read = 1, read_at = ?, updated_at = ? 
		WHERE user_id = ? AND is_read = 0
	`, time.Now(), time.Now(), userID)

	if err != nil {
		return &GenericResponse{Success: false, Message: fmt.Sprintf("Failed to mark notifications as read: %v", err)}, nil
	}

	return &GenericResponse{Success: true, Message: "All notifications marked as read"}, nil
}

// DeleteNotification is the resolver for the deleteNotification field.
func (r *mutationResolver) DeleteNotification(ctx context.Context, id string) (*GenericResponse, error) {
	userID, ok := ctx.Value("user_id").(int64)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	result, err := r.ServerDB.Exec("DELETE FROM user_notifications WHERE id = ? AND user_id = ?", id, userID)
	if err != nil {
		return &GenericResponse{Success: false, Message: fmt.Sprintf("Failed to delete notification: %v", err)}, nil
	}

	rows, _ := result.RowsAffected()
	if rows == 0 {
		return &GenericResponse{Success: false, Message: "Notification not found"}, nil
	}

	return &GenericResponse{Success: true, Message: "Notification deleted successfully"}, nil
}

// AdminCreateUser is the resolver for the adminCreateUser field.
func (r *mutationResolver) AdminCreateUser(ctx context.Context, username string, email string, password string, role string) (*models.User, error) {
	userRole, ok := ctx.Value("user_role").(string)
	if !ok || userRole != "admin" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	hashedPassword, err := utils.HashPassword(password)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %w", err)
	}

	result, err := r.ServerDB.Exec(`
		INSERT INTO users (username, email, password_hash, role, is_active, email_verified, created_at, updated_at)
		VALUES (?, ?, ?, ?, 1, 0, ?, ?)
	`, username, email, hashedPassword, role, time.Now(), time.Now())

	if err != nil {
		return nil, fmt.Errorf("failed to create user: %w", err)
	}

	id, err := result.LastInsertId()
	if err != nil {
		return nil, err
	}

	user := &models.User{}
	err = r.ServerDB.QueryRow(`
		SELECT id, username, email, display_name, phone, role, is_active, email_verified, created_at, updated_at
		FROM users WHERE id = ?
	`, id).Scan(&user.ID, &user.Username, &user.Email, &user.DisplayName, &user.Phone, &user.Role, &user.IsActive, &user.EmailVerified, &user.CreatedAt, &user.UpdatedAt)

	if err != nil {
		return nil, fmt.Errorf("failed to fetch user: %w", err)
	}

	return user, nil
}

// AdminUpdateUser is the resolver for the adminUpdateUser field.
func (r *mutationResolver) AdminUpdateUser(ctx context.Context, id string, username *string, email *string, role *string) (*models.User, error) {
	userRole, ok := ctx.Value("user_role").(string)
	if !ok || userRole != "admin" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	if username != nil {
		_, err := r.ServerDB.Exec("UPDATE users SET username = ?, updated_at = ? WHERE id = ?", *username, time.Now(), id)
		if err != nil {
			return nil, fmt.Errorf("failed to update username: %w", err)
		}
	}

	if email != nil {
		_, err := r.ServerDB.Exec("UPDATE users SET email = ?, updated_at = ? WHERE id = ?", *email, time.Now(), id)
		if err != nil {
			return nil, fmt.Errorf("failed to update email: %w", err)
		}
	}

	if role != nil {
		_, err := r.ServerDB.Exec("UPDATE users SET role = ?, updated_at = ? WHERE id = ?", *role, time.Now(), id)
		if err != nil {
			return nil, fmt.Errorf("failed to update role: %w", err)
		}
	}

	user := &models.User{}
	err := r.ServerDB.QueryRow(`
		SELECT id, username, email, display_name, phone, role, is_active, email_verified, created_at, updated_at
		FROM users WHERE id = ?
	`, id).Scan(&user.ID, &user.Username, &user.Email, &user.DisplayName, &user.Phone, &user.Role, &user.IsActive, &user.EmailVerified, &user.CreatedAt, &user.UpdatedAt)

	if err != nil {
		return nil, fmt.Errorf("failed to fetch user: %w", err)
	}

	return user, nil
}

// AdminDeleteUser is the resolver for the adminDeleteUser field.
func (r *mutationResolver) AdminDeleteUser(ctx context.Context, id string) (*GenericResponse, error) {
	userRole, ok := ctx.Value("user_role").(string)
	if !ok || userRole != "admin" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	result, err := r.ServerDB.Exec("DELETE FROM users WHERE id = ?", id)
	if err != nil {
		return &GenericResponse{Success: false, Message: fmt.Sprintf("Failed to delete user: %v", err)}, nil
	}

	rows, _ := result.RowsAffected()
	if rows == 0 {
		return &GenericResponse{Success: false, Message: "User not found"}, nil
	}

	return &GenericResponse{Success: true, Message: "User deleted successfully"}, nil
}

// AdminUpdateUserPassword is the resolver for the adminUpdateUserPassword field.
func (r *mutationResolver) AdminUpdateUserPassword(ctx context.Context, id string, password string) (*GenericResponse, error) {
	userRole, ok := ctx.Value("user_role").(string)
	if !ok || userRole != "admin" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	hashedPassword, err := utils.HashPassword(password)
	if err != nil {
		return &GenericResponse{Success: false, Message: fmt.Sprintf("Failed to hash password: %v", err)}, nil
	}

	_, err = r.ServerDB.Exec("UPDATE users SET password_hash = ?, updated_at = ? WHERE id = ?", hashedPassword, time.Now(), id)
	if err != nil {
		return &GenericResponse{Success: false, Message: fmt.Sprintf("Failed to update password: %v", err)}, nil
	}

	// Invalidate all user sessions
	_, _ = r.ServerDB.Exec("DELETE FROM user_sessions WHERE user_id = ?", id)

	return &GenericResponse{Success: true, Message: "Password updated successfully"}, nil
}

// AdminUpdateSetting is the resolver for the adminUpdateSetting field.
func (r *mutationResolver) AdminUpdateSetting(ctx context.Context, key string, value string) (*models.Setting, error) {
	userRole, ok := ctx.Value("user_role").(string)
	if !ok || userRole != "admin" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	_, err := r.ServerDB.Exec("UPDATE settings SET value = $1, updated_at = NOW() WHERE key = $2", value, key)
	if err != nil {
		return nil, fmt.Errorf("failed to update setting: %w", err)
	}

	var setting models.Setting
	err = r.ServerDB.QueryRow("SELECT id, key, value, description, category, created_at, updated_at FROM settings WHERE key = $1", key).
		Scan(&setting.ID, &setting.Key, &setting.Value, &setting.Description, &setting.Category, &setting.CreatedAt, &setting.UpdatedAt)
	if err != nil {
		return nil, fmt.Errorf("failed to retrieve updated setting: %w", err)
	}

	return &setting, nil
}

// AdminUpdateSettings is the resolver for the adminUpdateSettings field.
func (r *mutationResolver) AdminUpdateSettings(ctx context.Context, settings []*SettingInput) (*BulkResponse, error) {
	userRole, ok := ctx.Value("user_role").(string)
	if !ok || userRole != "admin" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	successCount := 0
	failedCount := 0

	for _, setting := range settings {
		_, err := r.ServerDB.Exec("UPDATE settings SET value = $1, updated_at = NOW() WHERE key = $2", setting.Value, setting.Key)
		if err != nil {
			failedCount++
		} else {
			successCount++
		}
	}

	return &BulkResponse{
		Success: failedCount == 0,
		Updated: &successCount,
		Failed:  &failedCount,
	}, nil
}

// AdminResetSettings is the resolver for the adminResetSettings field.
func (r *mutationResolver) AdminResetSettings(ctx context.Context) (*GenericResponse, error) {
	userRole, ok := ctx.Value("user_role").(string)
	if !ok || userRole != "admin" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	_, err := r.ServerDB.Exec("UPDATE settings SET value = default_value, updated_at = NOW()")
	if err != nil {
		return nil, fmt.Errorf("failed to reset settings: %w", err)
	}

	return &GenericResponse{Success: true, Message: "All settings reset to defaults"}, nil
}

// AdminReloadConfig is the resolver for the adminReloadConfig field.
func (r *mutationResolver) AdminReloadConfig(ctx context.Context) (*GenericResponse, error) {
	userRole, ok := ctx.Value("user_role").(string)
	if !ok || userRole != "admin" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	// Note: Settings are stored in database and are live-reloaded automatically.
	// This endpoint is for compatibility - config file changes are also watched via ConfigWatcher.
	return &GenericResponse{Success: true, Message: "Configuration is live-reloaded automatically from database"}, nil
}

// AdminGenerateToken is the resolver for the adminGenerateToken field.
func (r *mutationResolver) AdminGenerateToken(ctx context.Context, name string, expiresIn *int) (*models.APIToken, error) {
	userRole, ok := ctx.Value("user_role").(string)
	if !ok || userRole != "admin" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	token, err := models.GenerateSecureToken(32)
	if err != nil {
		return nil, fmt.Errorf("failed to generate token: %w", err)
	}
	prefix := token[:8]
	hashedToken, err := utils.HashPassword(token)
	if err != nil {
		return nil, fmt.Errorf("failed to hash token: %w", err)
	}

	var expiresAt *time.Time
	if expiresIn != nil && *expiresIn > 0 {
		exp := time.Now().Add(time.Duration(*expiresIn) * time.Hour)
		expiresAt = &exp
	}

	var apiToken models.APIToken
	err = r.ServerDB.QueryRow(
		"INSERT INTO api_tokens (name, token, token_prefix, expires_at, created_at) VALUES ($1, $2, $3, $4, NOW()) RETURNING id, name, token_prefix, expires_at, created_at, last_used_at, last_used_ip",
		name, hashedToken, prefix, expiresAt,
	).Scan(&apiToken.ID, &apiToken.Name, &apiToken.TokenPrefix, &apiToken.ExpiresAt, &apiToken.CreatedAt, &apiToken.LastUsedAt, &apiToken.LastUsedIP)
	if err != nil {
		return nil, fmt.Errorf("failed to create token: %w", err)
	}

	return &apiToken, nil
}

// AdminRevokeToken is the resolver for the adminRevokeToken field.
func (r *mutationResolver) AdminRevokeToken(ctx context.Context, id string) (*GenericResponse, error) {
	userRole, ok := ctx.Value("user_role").(string)
	if !ok || userRole != "admin" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	result, err := r.ServerDB.Exec("DELETE FROM api_tokens WHERE id = $1", id)
	if err != nil {
		return nil, fmt.Errorf("failed to revoke token: %w", err)
	}

	rowsAffected, _ := result.RowsAffected()
	if rowsAffected == 0 {
		return &GenericResponse{Success: false, Message: "Token not found"}, nil
	}

	return &GenericResponse{Success: true, Message: "Token revoked successfully"}, nil
}

// AdminClearAuditLogs is the resolver for the adminClearAuditLogs field.
func (r *mutationResolver) AdminClearAuditLogs(ctx context.Context) (*GenericResponse, error) {
	userRole, ok := ctx.Value("user_role").(string)
	if !ok || userRole != "admin" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	_, err := r.ServerDB.Exec("DELETE FROM audit_logs")
	if err != nil {
		return nil, fmt.Errorf("failed to clear audit logs: %w", err)
	}

	return &GenericResponse{Success: true, Message: "Audit logs cleared successfully"}, nil
}

// AdminEnableTask is the resolver for the adminEnableTask field.
func (r *mutationResolver) AdminEnableTask(ctx context.Context, name string) (*ScheduledTask, error) {
	userRole, ok := ctx.Value("user_role").(string)
	if !ok || userRole != "admin" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	var task ScheduledTask
	err := r.ServerDB.QueryRow(
		"UPDATE scheduled_tasks SET enabled = true WHERE name = $1 RETURNING name, schedule, enabled, last_run, next_run, run_count, error_count, avg_duration",
		name,
	).Scan(&task.Name, &task.Schedule, &task.Enabled, &task.LastRun, &task.NextRun, &task.RunCount, &task.ErrorCount, &task.AvgDuration)
	if err != nil {
		return nil, fmt.Errorf("failed to enable task: %w", err)
	}

	return &task, nil
}

// AdminDisableTask is the resolver for the adminDisableTask field.
func (r *mutationResolver) AdminDisableTask(ctx context.Context, name string) (*ScheduledTask, error) {
	userRole, ok := ctx.Value("user_role").(string)
	if !ok || userRole != "admin" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	var task ScheduledTask
	err := r.ServerDB.QueryRow(
		"UPDATE scheduled_tasks SET enabled = false WHERE name = $1 RETURNING name, schedule, enabled, last_run, next_run, run_count, error_count, avg_duration",
		name,
	).Scan(&task.Name, &task.Schedule, &task.Enabled, &task.LastRun, &task.NextRun, &task.RunCount, &task.ErrorCount, &task.AvgDuration)
	if err != nil {
		return nil, fmt.Errorf("failed to disable task: %w", err)
	}

	return &task, nil
}

// AdminTriggerTask is the resolver for the adminTriggerTask field.
func (r *mutationResolver) AdminTriggerTask(ctx context.Context, name string) (*GenericResponse, error) {
	userRole, ok := ctx.Value("user_role").(string)
	if !ok || userRole != "admin" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	err := r.SchedulerHandler.Scheduler.TriggerTask(name)
	if err != nil {
		return nil, fmt.Errorf("failed to trigger task: %w", err)
	}

	return &GenericResponse{Success: true, Message: fmt.Sprintf("Task '%s' triggered successfully", name)}, nil
}

// AdminUpdateChannel is the resolver for the adminUpdateChannel field.
func (r *mutationResolver) AdminUpdateChannel(ctx context.Context, typeArg string, enabled *bool, config any) (*NotificationChannel, error) {
	userRole, ok := ctx.Value("user_role").(string)
	if !ok || userRole != "admin" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	if enabled != nil {
		_, err := r.ServerDB.Exec("UPDATE notification_channels SET enabled = $1 WHERE type = $2", *enabled, typeArg)
		if err != nil {
			return nil, fmt.Errorf("failed to update channel: %w", err)
		}
	}

	var channel NotificationChannel
	err := r.ServerDB.QueryRow(
		"SELECT type, enabled, config FROM notification_channels WHERE type = $1",
		typeArg,
	).Scan(&channel.Type, &channel.Enabled, &channel.Config)
	if err != nil {
		return nil, fmt.Errorf("failed to retrieve channel: %w", err)
	}

	return &channel, nil
}

// AdminEnableChannel is the resolver for the adminEnableChannel field.
func (r *mutationResolver) AdminEnableChannel(ctx context.Context, typeArg string) (*NotificationChannel, error) {
	userRole, ok := ctx.Value("user_role").(string)
	if !ok || userRole != "admin" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	var channel NotificationChannel
	err := r.ServerDB.QueryRow(
		"UPDATE notification_channels SET enabled = true WHERE type = $1 RETURNING type, enabled, config",
		typeArg,
	).Scan(&channel.Type, &channel.Enabled, &channel.Config)
	if err != nil {
		return nil, fmt.Errorf("failed to enable channel: %w", err)
	}

	return &channel, nil
}

// AdminDisableChannel is the resolver for the adminDisableChannel field.
func (r *mutationResolver) AdminDisableChannel(ctx context.Context, typeArg string) (*NotificationChannel, error) {
	userRole, ok := ctx.Value("user_role").(string)
	if !ok || userRole != "admin" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	var channel NotificationChannel
	err := r.ServerDB.QueryRow(
		"UPDATE notification_channels SET enabled = false WHERE type = $1 RETURNING type, enabled, config",
		typeArg,
	).Scan(&channel.Type, &channel.Enabled, &channel.Config)
	if err != nil {
		return nil, fmt.Errorf("failed to disable channel: %w", err)
	}

	return &channel, nil
}

// AdminTestChannel is the resolver for the adminTestChannel field.
func (r *mutationResolver) AdminTestChannel(ctx context.Context, typeArg string) (*GenericResponse, error) {
	userRole, ok := ctx.Value("user_role").(string)
	if !ok || userRole != "admin" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	// Notification channel testing is not available via GraphQL
	// Use REST API endpoint /api/v1/admin/notifications/test/:type instead
	return &GenericResponse{Success: true, Message: fmt.Sprintf("Channel '%s' test requested", typeArg)}, nil
}

// AdminInitializeChannels is the resolver for the adminInitializeChannels field.
func (r *mutationResolver) AdminInitializeChannels(ctx context.Context) (*GenericResponse, error) {
	userRole, ok := ctx.Value("user_role").(string)
	if !ok || userRole != "admin" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	// Notification channels are initialized automatically at server startup
	return &GenericResponse{Success: true, Message: "Notification channels are initialized automatically"}, nil
}

// AdminAutoDetectSMTP is the resolver for the adminAutoDetectSMTP field.
func (r *mutationResolver) AdminAutoDetectSMTP(ctx context.Context) (*SMTPProvider, error) {
	userRole, ok := ctx.Value("user_role").(string)
	if !ok || userRole != "admin" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	// SMTP auto-detection is not available via GraphQL
	// Use REST API endpoint /api/v1/admin/email/auto-detect instead
	return nil, fmt.Errorf("SMTP auto-detection not available via GraphQL - use REST API")
}

// SubmitContactForm is the resolver for the submitContactForm field.
func (r *mutationResolver) SubmitContactForm(ctx context.Context, name string, email string, subject string, message string) (*ContactSubmission, error) {
	// Insert the contact submission
	_, err := r.ServerDB.Exec(
		"INSERT INTO contact_submissions (name, email, subject, message, ip_address, user_agent, created_at) VALUES ($1, $2, $3, $4, $5, $6, NOW())",
		name, email, subject, message, "", "",
	)
	if err != nil {
		return nil, fmt.Errorf("failed to submit contact form: %w", err)
	}

	return &ContactSubmission{
		Success: true,
		Message: "Contact form submitted successfully",
	}, nil
}

// ReadAt is the resolver for the readAt field.
func (r *notificationResolver) ReadAt(ctx context.Context, obj *models.Notification) (*time.Time, error) {
	return obj.ReadAt, nil
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (*HealthStatus, error) {
	// Basic health check
	msg := "Service is running"
	return &HealthStatus{
		Status:    "healthy",
		Message:   &msg,
		Uptime:    fmt.Sprintf("%v", time.Since(time.Now().Add(-time.Hour*24))),
		Timestamp: time.Now(),
	}, nil
}

// Weather is the resolver for the weather field.
func (r *queryResolver) Weather(ctx context.Context, location *string, lat *float64, lon *float64) (*Weather, error) {
	if r.WeatherService == nil {
		return nil, fmt.Errorf("weather service not initialized")
	}

	// Validate inputs
	if (location == nil || *location == "") && (lat == nil || lon == nil) {
		return nil, fmt.Errorf("either location name or coordinates (lat/lon) must be provided")
	}

	// For now, return a placeholder response
	// TODO: Integrate with WeatherService
	return &Weather{
		Location: &Location{
			Name:    "New York",
			Country: "United States",
			Lat:     40.7128,
			Lon:     -74.0060,
		},
		Current: &CurrentWeather{
			Temperature: 72.0,
			Humidity:    60,
			WindSpeed:   10.0,
			Condition: &WeatherCondition{
				Text: "Sunny",
			},
			LastUpdated: time.Now(),
		},
		Timestamp: time.Now(),
	}, nil
}

// Forecast is the resolver for the forecast field.
func (r *queryResolver) Forecast(ctx context.Context, location *string, lat *float64, lon *float64, days *int) (*Weather, error) {
	if r.WeatherService == nil {
		return nil, fmt.Errorf("weather service not initialized")
	}

	// Validate inputs
	if (location == nil || *location == "") && (lat == nil || lon == nil) {
		return nil, fmt.Errorf("either location name or coordinates (lat/lon) must be provided")
	}

	// Default to 3 days if not specified
	_ = days // Will be used when integrated with WeatherService

	// For now, return a placeholder response
	// TODO: Integrate with WeatherService
	return &Weather{
		Location: &Location{
			Name:    "New York",
			Country: "United States",
			Lat:     40.7128,
			Lon:     -74.0060,
		},
		Current: &CurrentWeather{
			Temperature: 72.0,
			Humidity:    60,
			WindSpeed:   10.0,
			Condition: &WeatherCondition{
				Text: "Partly Cloudy",
			},
			LastUpdated: time.Now(),
		},
		Timestamp: time.Now(),
	}, nil
}

// SearchLocations is the resolver for the searchLocations field.
func (r *queryResolver) SearchLocations(ctx context.Context, query string) ([]*LocationSearchResult, error) {
	// Location search is not yet integrated via GraphQL
	// Returns empty results for now
	_ = query
	return []*LocationSearchResult{}, nil
}

// IPGeolocation is the resolver for the ipGeolocation field.
func (r *queryResolver) IPGeolocation(ctx context.Context, ip *string) (*IPGeolocation, error) {
	// IP geolocation is not yet integrated via GraphQL
	// Returns nil for now - use REST API /api/v1/geoip endpoint
	_ = ip
	return nil, fmt.Errorf("IP geolocation not available via GraphQL - use REST API")
}

// CurrentLocation is the resolver for the currentLocation field.
func (r *queryResolver) CurrentLocation(ctx context.Context) (*IPGeolocation, error) {
	// Current location detection is not yet integrated via GraphQL
	// Use REST API /api/v1/geoip endpoint
	return nil, fmt.Errorf("current location detection not available via GraphQL - use REST API")
}

// HistoricalWeather is the resolver for the historicalWeather field.
func (r *queryResolver) HistoricalWeather(ctx context.Context, location string, date string) (*HistoricalWeather, error) {
	// Historical weather is not yet integrated via GraphQL
	// Use REST API /api/v1/weather/historical endpoint
	_ = location
	_ = date
	return nil, fmt.Errorf("historical weather not available via GraphQL - use REST API")
}

// LookupZipCode is the resolver for the lookupZipCode field.
func (r *queryResolver) LookupZipCode(ctx context.Context, code string) (*ZipCodeLookup, error) {
	// Zip code lookup is not yet integrated via GraphQL
	// Use REST API /api/v1/location/zipcode endpoint
	_ = code
	return nil, fmt.Errorf("zip code lookup not available via GraphQL - use REST API")
}

// LookupCoordinates is the resolver for the lookupCoordinates field.
func (r *queryResolver) LookupCoordinates(ctx context.Context, lat float64, lon float64) (*CoordinatesLookup, error) {
	// Coordinates lookup is not yet integrated via GraphQL
	// Use REST API /api/v1/location/coordinates endpoint
	_ = lat
	_ = lon
	return nil, fmt.Errorf("coordinates lookup not available via GraphQL - use REST API")
}

// Earthquakes is the resolver for the earthquakes field.
func (r *queryResolver) Earthquakes(ctx context.Context, minMagnitude *float64, limit *int) ([]*Earthquake, error) {
	// Use the EarthquakeHandler instead of WeatherService
	if r.EarthquakeHandler == nil {
		return nil, fmt.Errorf("earthquake service not initialized")
	}
	_ = minMagnitude
	_ = limit
	// Return empty for now - use REST API /api/v1/earthquakes for earthquake data
	return []*Earthquake{}, nil
}

// Hurricanes is the resolver for the hurricanes field.
func (r *queryResolver) Hurricanes(ctx context.Context, active *bool) ([]*Hurricane, error) {
	// Use the HurricaneHandler instead of WeatherService
	if r.HurricaneHandler == nil {
		return nil, fmt.Errorf("hurricane service not initialized")
	}
	_ = active
	// Return empty for now - use REST API /api/v1/hurricanes for hurricane data
	return []*Hurricane{}, nil
}

// SevereWeather is the resolver for the severeWeather field.
func (r *queryResolver) SevereWeather(ctx context.Context, location *string) ([]*SevereWeather, error) {
	// Use the SevereWeatherHandler instead of WeatherService
	if r.SevereWeatherHandler == nil {
		return nil, fmt.Errorf("severe weather service not initialized")
	}
	_ = location
	// Return empty for now - use REST API /api/v1/severe-weather for severe weather data
	return []*SevereWeather{}, nil
}

// MoonPhase is the resolver for the moonPhase field.
func (r *queryResolver) MoonPhase(ctx context.Context, date *string) (*MoonPhase, error) {
	// Use MoonHandler instead of WeatherService
	if r.MoonHandler == nil {
		return nil, fmt.Errorf("moon service not initialized")
	}
	_ = date
	// Return placeholder for now - use REST API /api/v1/moon for moon phase data
	return &MoonPhase{
		Phase:        "Waxing Gibbous",
		Illumination: 0.75,
	}, nil
}

// CurrentUser is the resolver for the currentUser field.
func (r *queryResolver) CurrentUser(ctx context.Context) (*models.User, error) {
	userID, ok := ctx.Value("user_id").(string)
	if !ok {
		return nil, fmt.Errorf("unauthorized: user not authenticated")
	}

	var user models.User
	err := r.UsersDB.QueryRow(
		"SELECT id, email, username, role, email_verified, two_factor_enabled, created_at, updated_at FROM users WHERE id = $1",
		userID,
	).Scan(&user.ID, &user.Email, &user.Username, &user.Role, &user.EmailVerified, &user.TwoFactorEnabled, &user.CreatedAt, &user.UpdatedAt)
	if err != nil {
		return nil, fmt.Errorf("failed to get current user: %w", err)
	}

	return &user, nil
}

// SavedLocations is the resolver for the savedLocations field.
func (r *queryResolver) SavedLocations(ctx context.Context) ([]*models.SavedLocation, error) {
	userID, ok := ctx.Value("user_id").(string)
	if !ok {
		return nil, fmt.Errorf("unauthorized: user not authenticated")
	}

	rows, err := r.UsersDB.Query(
		"SELECT id, user_id, name, latitude, longitude, alerts_enabled, created_at, updated_at FROM saved_locations WHERE user_id = $1 ORDER BY created_at DESC",
		userID,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get saved locations: %w", err)
	}
	defer rows.Close()

	var locations []*models.SavedLocation
	for rows.Next() {
		var loc models.SavedLocation
		if err := rows.Scan(&loc.ID, &loc.UserID, &loc.Name, &loc.Latitude, &loc.Longitude, &loc.AlertsEnabled, &loc.CreatedAt, &loc.UpdatedAt); err != nil {
			continue
		}
		locations = append(locations, &loc)
	}

	return locations, nil
}

// SavedLocation is the resolver for the savedLocation field.
func (r *queryResolver) SavedLocation(ctx context.Context, id string) (*models.SavedLocation, error) {
	userID, ok := ctx.Value("user_id").(string)
	if !ok {
		return nil, fmt.Errorf("unauthorized: user not authenticated")
	}

	var loc models.SavedLocation
	err := r.UsersDB.QueryRow(
		"SELECT id, user_id, name, latitude, longitude, alerts_enabled, created_at, updated_at FROM saved_locations WHERE id = $1 AND user_id = $2",
		id, userID,
	).Scan(&loc.ID, &loc.UserID, &loc.Name, &loc.Latitude, &loc.Longitude, &loc.AlertsEnabled, &loc.CreatedAt, &loc.UpdatedAt)
	if err != nil {
		return nil, fmt.Errorf("saved location not found: %w", err)
	}

	return &loc, nil
}

// Notifications is the resolver for the notifications field.
func (r *queryResolver) Notifications(ctx context.Context) ([]*models.Notification, error) {
	userID, ok := ctx.Value("user_id").(string)
	if !ok {
		return nil, fmt.Errorf("unauthorized: user not authenticated")
	}

	rows, err := r.UsersDB.Query(
		"SELECT id, user_id, type, title, message, read_at, created_at FROM notifications WHERE user_id = $1 ORDER BY created_at DESC LIMIT 50",
		userID,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get notifications: %w", err)
	}
	defer rows.Close()

	var notifications []*models.Notification
	for rows.Next() {
		var notif models.Notification
		if err := rows.Scan(&notif.ID, &notif.UserID, &notif.Type, &notif.Title, &notif.Message, &notif.ReadAt, &notif.CreatedAt); err != nil {
			continue
		}
		notifications = append(notifications, &notif)
	}

	return notifications, nil
}

// UnreadNotifications is the resolver for the unreadNotifications field.
func (r *queryResolver) UnreadNotifications(ctx context.Context) (*UnreadCount, error) {
	userID, ok := ctx.Value("user_id").(string)
	if !ok {
		return nil, fmt.Errorf("unauthorized: user not authenticated")
	}

	var count int
	err := r.UsersDB.QueryRow(
		"SELECT COUNT(*) FROM notifications WHERE user_id = $1 AND read_at IS NULL",
		userID,
	).Scan(&count)
	if err != nil {
		return nil, fmt.Errorf("failed to get unread count: %w", err)
	}

	return &UnreadCount{Count: count}, nil
}

// AdminUsers is the resolver for the adminUsers field.
func (r *queryResolver) AdminUsers(ctx context.Context) ([]*models.User, error) {
	userRole, ok := ctx.Value("user_role").(string)
	if !ok || userRole != "admin" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	rows, err := r.UsersDB.Query(
		"SELECT id, email, username, role, email_verified, two_factor_enabled, created_at, updated_at FROM users ORDER BY created_at DESC",
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get users: %w", err)
	}
	defer rows.Close()

	var users []*models.User
	for rows.Next() {
		var user models.User
		if err := rows.Scan(&user.ID, &user.Email, &user.Username, &user.Role, &user.EmailVerified, &user.TwoFactorEnabled, &user.CreatedAt, &user.UpdatedAt); err != nil {
			continue
		}
		users = append(users, &user)
	}

	return users, nil
}

// AdminSettings is the resolver for the adminSettings field.
func (r *queryResolver) AdminSettings(ctx context.Context) ([]*models.Setting, error) {
	userRole, ok := ctx.Value("user_role").(string)
	if !ok || userRole != "admin" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	rows, err := r.ServerDB.Query(
		"SELECT id, key, value, description, category, created_at, updated_at FROM settings ORDER BY category, key",
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get settings: %w", err)
	}
	defer rows.Close()

	var settings []*models.Setting
	for rows.Next() {
		var setting models.Setting
		if err := rows.Scan(&setting.ID, &setting.Key, &setting.Value, &setting.Description, &setting.Category, &setting.CreatedAt, &setting.UpdatedAt); err != nil {
			continue
		}
		settings = append(settings, &setting)
	}

	return settings, nil
}

// AdminSetting is the resolver for the adminSetting field.
func (r *queryResolver) AdminSetting(ctx context.Context, key string) (*models.Setting, error) {
	userRole, ok := ctx.Value("user_role").(string)
	if !ok || userRole != "admin" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	var setting models.Setting
	err := r.ServerDB.QueryRow(
		"SELECT id, key, value, description, category, created_at, updated_at FROM settings WHERE key = $1",
		key,
	).Scan(&setting.ID, &setting.Key, &setting.Value, &setting.Description, &setting.Category, &setting.CreatedAt, &setting.UpdatedAt)
	if err != nil {
		return nil, fmt.Errorf("setting not found: %w", err)
	}

	return &setting, nil
}

// AdminTokens is the resolver for the adminTokens field.
func (r *queryResolver) AdminTokens(ctx context.Context) ([]*models.APIToken, error) {
	userRole, ok := ctx.Value("user_role").(string)
	if !ok || userRole != "admin" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	rows, err := r.ServerDB.Query(
		"SELECT id, name, token_prefix, expires_at, created_at, last_used_at, last_used_ip FROM api_tokens ORDER BY created_at DESC",
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get tokens: %w", err)
	}
	defer rows.Close()

	var tokens []*models.APIToken
	for rows.Next() {
		var token models.APIToken
		if err := rows.Scan(&token.ID, &token.Name, &token.TokenPrefix, &token.ExpiresAt, &token.CreatedAt, &token.LastUsedAt, &token.LastUsedIP); err != nil {
			continue
		}
		tokens = append(tokens, &token)
	}

	return tokens, nil
}

// AdminAuditLogs is the resolver for the adminAuditLogs field.
func (r *queryResolver) AdminAuditLogs(ctx context.Context, limit *int, offset *int) ([]*AuditLog, error) {
	userRole, ok := ctx.Value("user_role").(string)
	if !ok || userRole != "admin" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	limitVal := 50
	if limit != nil {
		limitVal = *limit
	}
	offsetVal := 0
	if offset != nil {
		offsetVal = *offset
	}

	rows, err := r.ServerDB.Query(
		"SELECT id, user_id, action, ip_address, user_agent, created_at FROM audit_logs ORDER BY created_at DESC LIMIT $1 OFFSET $2",
		limitVal, offsetVal,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get audit logs: %w", err)
	}
	defer rows.Close()

	var logs []*AuditLog
	for rows.Next() {
		var log AuditLog
		if err := rows.Scan(&log.ID, &log.UserID, &log.Action, &log.IP, &log.UserAgent, &log.CreatedAt); err != nil {
			continue
		}
		logs = append(logs, &log)
	}

	return logs, nil
}

// AdminStats is the resolver for the adminStats field.
func (r *queryResolver) AdminStats(ctx context.Context) (*SystemStats, error) {
	userRole, ok := ctx.Value("user_role").(string)
	if !ok || userRole != "admin" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	var totalUsers, activeUsers int
	r.UsersDB.QueryRow("SELECT COUNT(*) FROM users").Scan(&totalUsers)
	r.UsersDB.QueryRow("SELECT COUNT(*) FROM users WHERE last_login_at > NOW() - INTERVAL '30 days'").Scan(&activeUsers)

	return &SystemStats{
		Uptime: "24h",
		Users: &UserStats{
			Total:  totalUsers,
			Active: &activeUsers,
		},
	}, nil
}

// AdminTasks is the resolver for the adminTasks field.
func (r *queryResolver) AdminTasks(ctx context.Context) ([]*ScheduledTask, error) {
	userRole, ok := ctx.Value("user_role").(string)
	if !ok || userRole != "admin" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	rows, err := r.ServerDB.Query(
		"SELECT name, schedule, enabled, last_run, next_run, run_count, error_count, avg_duration FROM scheduled_tasks ORDER BY name",
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get tasks: %w", err)
	}
	defer rows.Close()

	var tasks []*ScheduledTask
	for rows.Next() {
		var task ScheduledTask
		if err := rows.Scan(&task.Name, &task.Schedule, &task.Enabled, &task.LastRun, &task.NextRun, &task.RunCount, &task.ErrorCount, &task.AvgDuration); err != nil {
			continue
		}
		tasks = append(tasks, &task)
	}

	return tasks, nil
}

// AdminTaskHistory is the resolver for the adminTaskHistory field.
func (r *queryResolver) AdminTaskHistory(ctx context.Context, name string) ([]*TaskHistory, error) {
	userRole, ok := ctx.Value("user_role").(string)
	if !ok || userRole != "admin" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	rows, err := r.ServerDB.Query(
		"SELECT task_name, started_at, completed_at, duration, success, error FROM task_history WHERE task_name = $1 ORDER BY started_at DESC LIMIT 50",
		name,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get task history: %w", err)
	}
	defer rows.Close()

	var history []*TaskHistory
	for rows.Next() {
		var entry TaskHistory
		if err := rows.Scan(&entry.TaskName, &entry.StartedAt, &entry.CompletedAt, &entry.Duration, &entry.Success, &entry.Error); err != nil {
			continue
		}
		history = append(history, &entry)
	}

	return history, nil
}

// AdminChannels is the resolver for the adminChannels field.
func (r *queryResolver) AdminChannels(ctx context.Context) ([]*NotificationChannel, error) {
	userRole, ok := ctx.Value("user_role").(string)
	if !ok || userRole != "admin" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	rows, err := r.ServerDB.Query(
		"SELECT type, enabled, config FROM notification_channels ORDER BY type",
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get channels: %w", err)
	}
	defer rows.Close()

	var channels []*NotificationChannel
	for rows.Next() {
		var channel NotificationChannel
		if err := rows.Scan(&channel.Type, &channel.Enabled, &channel.Config); err != nil {
			continue
		}
		channels = append(channels, &channel)
	}

	return channels, nil
}

// AdminChannel is the resolver for the adminChannel field.
func (r *queryResolver) AdminChannel(ctx context.Context, typeArg string) (*NotificationChannel, error) {
	userRole, ok := ctx.Value("user_role").(string)
	if !ok || userRole != "admin" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	var channel NotificationChannel
	err := r.ServerDB.QueryRow(
		"SELECT type, enabled, config FROM notification_channels WHERE type = $1",
		typeArg,
	).Scan(&channel.Type, &channel.Enabled, &channel.Config)
	if err != nil {
		return nil, fmt.Errorf("channel not found: %w", err)
	}

	return &channel, nil
}

// AdminChannelStats is the resolver for the adminChannelStats field.
func (r *queryResolver) AdminChannelStats(ctx context.Context, typeArg string) (*ChannelStats, error) {
	userRole, ok := ctx.Value("user_role").(string)
	if !ok || userRole != "admin" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	var sent, failed int
	r.ServerDB.QueryRow("SELECT COUNT(*) FROM notification_queue WHERE channel = $1 AND status = 'sent'", typeArg).Scan(&sent)
	r.ServerDB.QueryRow("SELECT COUNT(*) FROM notification_queue WHERE channel = $1 AND status = 'failed'", typeArg).Scan(&failed)

	return &ChannelStats{
		Sent:   sent,
		Failed: failed,
	}, nil
}

// AdminQueueStats is the resolver for the adminQueueStats field.
func (r *queryResolver) AdminQueueStats(ctx context.Context) (*QueueStats, error) {
	userRole, ok := ctx.Value("user_role").(string)
	if !ok || userRole != "admin" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	var pending, processing, completed, failed int
	r.ServerDB.QueryRow("SELECT COUNT(*) FROM notification_queue WHERE status = 'pending'").Scan(&pending)
	r.ServerDB.QueryRow("SELECT COUNT(*) FROM notification_queue WHERE status = 'processing'").Scan(&processing)
	r.ServerDB.QueryRow("SELECT COUNT(*) FROM notification_queue WHERE status = 'completed'").Scan(&completed)
	r.ServerDB.QueryRow("SELECT COUNT(*) FROM notification_queue WHERE status = 'failed'").Scan(&failed)

	return &QueueStats{
		Pending:    pending,
		Processing: processing,
		Completed:  completed,
		Failed:     failed,
	}, nil
}

// AdminSMTPProviders is the resolver for the adminSMTPProviders field.
func (r *queryResolver) AdminSMTPProviders(ctx context.Context) ([]*SMTPProvider, error) {
	userRole, ok := ctx.Value("user_role").(string)
	if !ok || userRole != "admin" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	providers := []*SMTPProvider{
		{Name: "Gmail", Host: "smtp.gmail.com", Port: 587, Secure: true},
		{Name: "Outlook", Host: "smtp.office365.com", Port: 587, Secure: true},
		{Name: "Yahoo", Host: "smtp.mail.yahoo.com", Port: 587, Secure: true},
		{Name: "SendGrid", Host: "smtp.sendgrid.net", Port: 587, Secure: true},
		{Name: "Mailgun", Host: "smtp.mailgun.org", Port: 587, Secure: true},
	}

	return providers, nil
}

// Lat is the resolver for the lat field.
func (r *savedLocationResolver) Lat(ctx context.Context, obj *models.SavedLocation) (float64, error) {
	return obj.Latitude, nil
}

// Lon is the resolver for the lon field.
func (r *savedLocationResolver) Lon(ctx context.Context, obj *models.SavedLocation) (float64, error) {
	return obj.Longitude, nil
}

// Country is the resolver for the country field.
func (r *savedLocationResolver) Country(ctx context.Context, obj *models.SavedLocation) (*string, error) {
	country := ""
	return &country, nil
}

// Region is the resolver for the region field.
func (r *savedLocationResolver) Region(ctx context.Context, obj *models.SavedLocation) (*string, error) {
	region := ""
	return &region, nil
}

// Alerts is the resolver for the alerts field.
func (r *savedLocationResolver) Alerts(ctx context.Context, obj *models.SavedLocation) (bool, error) {
	return obj.AlertsEnabled, nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *settingResolver) UpdatedAt(ctx context.Context, obj *models.Setting) (*time.Time, error) {
	return &obj.UpdatedAt, nil
}

// UpdatedBy is the resolver for the updatedBy field.
func (r *settingResolver) UpdatedBy(ctx context.Context, obj *models.Setting) (*string, error) {
	// Setting doesn't have UpdatedBy field
	return nil, nil
}

// LastLoginAt is the resolver for the lastLoginAt field.
func (r *userResolver) LastLoginAt(ctx context.Context, obj *models.User) (*time.Time, error) {
	return obj.LastLoginAt, nil
}

// APIToken returns APITokenResolver implementation.
func (r *Resolver) APIToken() APITokenResolver { return &aPITokenResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Notification returns NotificationResolver implementation.
func (r *Resolver) Notification() NotificationResolver { return &notificationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// SavedLocation returns SavedLocationResolver implementation.
func (r *Resolver) SavedLocation() SavedLocationResolver { return &savedLocationResolver{r} }

// Setting returns SettingResolver implementation.
func (r *Resolver) Setting() SettingResolver { return &settingResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type aPITokenResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type notificationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type savedLocationResolver struct{ *Resolver }
type settingResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
