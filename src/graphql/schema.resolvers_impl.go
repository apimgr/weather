package graphql

// This file contains the actual resolver implementations
// It supplements schema.resolvers.go (which is regenerated by gqlgen)
// All resolver logic should be implemented here to avoid conflicts with gqlgen regeneration

import (
	"context"
	"database/sql"
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/apimgr/weather/src/server/model"
)

// Helper function to get user ID from context
func getUserIDFromContext(ctx context.Context) (int, error) {
	userID, ok := ctx.Value("user_id").(int)
	if !ok {
		return 0, fmt.Errorf("unauthorized: user not found in context")
	}
	return userID, nil
}

// Helper function to check if user is admin
func isAdminFromContext(ctx context.Context) bool {
	role, ok := ctx.Value("user_role").(string)
	return ok && role == "admin"
}

// Helper function to get IP from context
func getIPFromContext(ctx context.Context) string {
	ip, ok := ctx.Value("client_ip").(string)
	if !ok {
		return "unknown"
	}
	return ip
}

// ============================================================================
// QUERY RESOLVERS
// ============================================================================

// Health returns the current health status of the service
func (r *queryResolver) HealthImpl(ctx context.Context) (*HealthStatus, error) {
	// Basic health check - can be enhanced with actual health checks
	return &HealthStatus{
		Status:    "healthy",
		Message:   stringPtr("Service is running"),
		Uptime:    "up",
		Timestamp: time.Now(),
	}, nil
}

// Weather retrieves weather data for a location
func (r *queryResolver) WeatherImpl(ctx context.Context, location *string, lat *float64, lon *float64) (*Weather, error) {
	if r.WeatherService == nil {
		return nil, fmt.Errorf("weather service not initialized")
	}

	// Determine location query
	var locationQuery string
	if location != nil && *location != "" {
		locationQuery = *location
	} else if lat != nil && lon != nil {
		locationQuery = fmt.Sprintf("%f,%f", *lat, *lon)
	} else {
		return nil, fmt.Errorf("either location name or coordinates (lat/lon) must be provided")
	}

	// Fetch weather data from service
	weatherData, err := r.WeatherService.GetWeather(locationQuery)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch weather: %w", err)
	}

	// Convert to GraphQL type
	return convertWeatherToGraphQL(weatherData), nil
}

// Forecast retrieves weather forecast for a location
func (r *queryResolver) ForecastImpl(ctx context.Context, location *string, lat *float64, lon *float64, days *int) (*Weather, error) {
	if r.WeatherService == nil {
		return nil, fmt.Errorf("weather service not initialized")
	}

	// Default to 3 days if not specified
	forecastDays := 3
	if days != nil && *days > 0 && *days <= 10 {
		forecastDays = *days
	}

	// Determine location query
	var locationQuery string
	if location != nil && *location != "" {
		locationQuery = *location
	} else if lat != nil && lon != nil {
		locationQuery = fmt.Sprintf("%f,%f", *lat, *lon)
	} else {
		return nil, fmt.Errorf("either location name or coordinates (lat/lon) must be provided")
	}

	// Fetch forecast data from service
	forecastData, err := r.WeatherService.GetForecast(locationQuery, forecastDays)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch forecast: %w", err)
	}

	// Convert to GraphQL type
	return convertWeatherToGraphQL(forecastData), nil
}

// CurrentUser returns the currently authenticated user
func (r *queryResolver) CurrentUserImpl(ctx context.Context) (*models.User, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// Fetch user from database
	user, err := models.GetUserByID(r.UsersDB, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch user: %w", err)
	}

	return user, nil
}

// SavedLocations returns all saved locations for the current user
func (r *queryResolver) SavedLocationsImpl(ctx context.Context) ([]*models.SavedLocation, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// Fetch saved locations from database
	locations, err := models.GetSavedLocationsByUser(r.UsersDB, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch saved locations: %w", err)
	}

	return locations, nil
}

// SavedLocation returns a specific saved location by ID
func (r *queryResolver) SavedLocationImpl(ctx context.Context, id string) (*models.SavedLocation, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	locationID, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("invalid location ID")
	}

	// Fetch location and verify ownership
	location, err := models.GetSavedLocation(r.UsersDB, locationID)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("location not found")
		}
		return nil, fmt.Errorf("failed to fetch location: %w", err)
	}

	// Verify user owns this location
	if location.UserID != userID {
		return nil, fmt.Errorf("unauthorized: location does not belong to user")
	}

	return location, nil
}

// Notifications returns all notifications for the current user
func (r *queryResolver) NotificationsImpl(ctx context.Context) ([]*models.Notification, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// Fetch notifications from database
	notifications, err := models.GetNotificationsByUser(r.UsersDB, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch notifications: %w", err)
	}

	return notifications, nil
}

// UnreadNotifications returns the count of unread notifications
func (r *queryResolver) UnreadNotificationsImpl(ctx context.Context) (*UnreadCount, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// Count unread notifications
	count, err := models.CountUnreadNotifications(r.UsersDB, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to count unread notifications: %w", err)
	}

	return &UnreadCount{Count: count}, nil
}

// ============================================================================
// MUTATION RESOLVERS
// ============================================================================

// UpdateUserProfile updates the current user's profile
func (r *mutationResolver) UpdateUserProfileImpl(ctx context.Context, displayName *string, phone *string) (*models.User, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// Fetch current user
	user, err := models.GetUserByID(r.UsersDB, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch user: %w", err)
	}

	// Update fields
	if displayName != nil {
		user.DisplayName = *displayName
	}
	if phone != nil {
		user.Phone = *phone
	}

	// Save to database
	if err := user.Update(r.UsersDB); err != nil {
		return nil, fmt.Errorf("failed to update user: %w", err)
	}

	return user, nil
}

// CreateSavedLocation creates a new saved location for the current user
func (r *mutationResolver) CreateSavedLocationImpl(ctx context.Context, name string, lat float64, lon float64, country *string, region *string, alerts *bool) (*models.SavedLocation, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// Create location
	location := &models.SavedLocation{
		UserID:  userID,
		Name:    name,
		Lat:     lat,
		Lon:     lon,
		Alerts:  boolOrDefault(alerts, false),
	}

	if country != nil {
		location.Country = *country
	}
	if region != nil {
		location.Region = *region
	}

	// Save to database
	if err := location.Create(r.UsersDB); err != nil {
		return nil, fmt.Errorf("failed to create saved location: %w", err)
	}

	return location, nil
}

// UpdateSavedLocation updates an existing saved location
func (r *mutationResolver) UpdateSavedLocationImpl(ctx context.Context, id string, name *string, alerts *bool) (*models.SavedLocation, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	locationID, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("invalid location ID")
	}

	// Fetch location and verify ownership
	location, err := models.GetSavedLocation(r.UsersDB, locationID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch location: %w", err)
	}

	if location.UserID != userID {
		return nil, fmt.Errorf("unauthorized: location does not belong to user")
	}

	// Update fields
	if name != nil {
		location.Name = *name
	}
	if alerts != nil {
		location.Alerts = *alerts
	}

	// Save changes
	if err := location.Update(r.UsersDB); err != nil {
		return nil, fmt.Errorf("failed to update location: %w", err)
	}

	return location, nil
}

// DeleteSavedLocation deletes a saved location
func (r *mutationResolver) DeleteSavedLocationImpl(ctx context.Context, id string) (*GenericResponse, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	locationID, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("invalid location ID")
	}

	// Fetch location and verify ownership
	location, err := models.GetSavedLocation(r.UsersDB, locationID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch location: %w", err)
	}

	if location.UserID != userID {
		return nil, fmt.Errorf("unauthorized: location does not belong to user")
	}

	// Delete location
	if err := location.Delete(r.UsersDB); err != nil {
		return nil, fmt.Errorf("failed to delete location: %w", err)
	}

	return &GenericResponse{
		Success: true,
		Message: "Location deleted successfully",
	}, nil
}

// ToggleLocationAlerts toggles alert notifications for a saved location
func (r *mutationResolver) ToggleLocationAlertsImpl(ctx context.Context, id string) (*models.SavedLocation, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	locationID, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("invalid location ID")
	}

	// Fetch location and verify ownership
	location, err := models.GetSavedLocation(r.UsersDB, locationID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch location: %w", err)
	}

	if location.UserID != userID {
		return nil, fmt.Errorf("unauthorized: location does not belong to user")
	}

	// Toggle alerts
	location.Alerts = !location.Alerts

	// Save changes
	if err := location.Update(r.UsersDB); err != nil {
		return nil, fmt.Errorf("failed to update location: %w", err)
	}

	return location, nil
}

// MarkNotificationRead marks a notification as read
func (r *mutationResolver) MarkNotificationReadImpl(ctx context.Context, id string) (*models.Notification, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	notificationID, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("invalid notification ID")
	}

	// Fetch notification and verify ownership
	notification, err := models.GetNotification(r.UsersDB, notificationID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch notification: %w", err)
	}

	if notification.UserID != userID {
		return nil, fmt.Errorf("unauthorized: notification does not belong to user")
	}

	// Mark as read
	now := time.Now()
	notification.Read = true
	notification.ReadAt = &now

	if err := notification.Update(r.UsersDB); err != nil {
		return nil, fmt.Errorf("failed to update notification: %w", err)
	}

	return notification, nil
}

// MarkAllNotificationsRead marks all notifications as read for the current user
func (r *mutationResolver) MarkAllNotificationsReadImpl(ctx context.Context) (*GenericResponse, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// Mark all as read
	if err := models.MarkAllNotificationsRead(r.UsersDB, userID); err != nil {
		return nil, fmt.Errorf("failed to mark notifications as read: %w", err)
	}

	return &GenericResponse{
		Success: true,
		Message: "All notifications marked as read",
	}, nil
}

// DeleteNotification deletes a notification
func (r *mutationResolver) DeleteNotificationImpl(ctx context.Context, id string) (*GenericResponse, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	notificationID, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("invalid notification ID")
	}

	// Fetch notification and verify ownership
	notification, err := models.GetNotification(r.UsersDB, notificationID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch notification: %w", err)
	}

	if notification.UserID != userID {
		return nil, fmt.Errorf("unauthorized: notification does not belong to user")
	}

	// Delete notification
	if err := notification.Delete(r.UsersDB); err != nil {
		return nil, fmt.Errorf("failed to delete notification: %w", err)
	}

	return &GenericResponse{
		Success: true,
		Message: "Notification deleted successfully",
	}, nil
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

// Helper to convert weather data to GraphQL type
// This is a placeholder - actual implementation depends on WeatherService return type
func convertWeatherToGraphQL(data interface{}) *Weather {
	// TODO: Implement actual conversion based on WeatherService response structure
	return &Weather{
		Location: Location{
			Name:    "Sample Location",
			Country: "US",
			Lat:     0.0,
			Lon:     0.0,
		},
		Current: CurrentWeather{
			Temperature: 72.0,
			Humidity:    60,
			WindSpeed:   10.0,
			Condition: WeatherCondition{
				Text: "Sunny",
			},
			LastUpdated: time.Now(),
		},
		Timestamp: time.Now(),
	}
}

// Helper functions for optional values
func stringPtr(s string) *string {
	return &s
}

func intPtr(i int) *int {
	return &i
}

func boolOrDefault(b *bool, def bool) bool {
	if b == nil {
		return def
	}
	return *b
}
