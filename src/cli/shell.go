package cli

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// handleShellCommand handles --shell flag per AI.md PART 8
func (c *CLI) handleShellCommand(cmd string, args []string) error {
	binaryName := filepath.Base(os.Args[0])

	switch cmd {
	case "--help", "help":
		c.showShellHelp(binaryName)
		os.Exit(0)
	case "completions":
		shell := ""
		if len(args) > 0 {
			shell = args[0]
		} else {
			shell = detectShell()
		}
		printCompletions(binaryName, shell)
		os.Exit(0)
	case "init":
		shell := ""
		if len(args) > 0 {
			shell = args[0]
		} else {
			shell = detectShell()
		}
		printInit(binaryName, shell)
		os.Exit(0)
	default:
		return fmt.Errorf("unknown shell command: %s (use --shell --help)", cmd)
	}
	return nil
}

// showShellHelp displays shell integration help per AI.md PART 25
func (c *CLI) showShellHelp(binaryName string) {
	fmt.Println("Shell integration commands:")
	fmt.Println()
	fmt.Println("  completions [SHELL]   Print shell completion script")
	fmt.Println("                        Auto-detects shell if SHELL omitted")
	fmt.Println("                        Supported: bash, zsh, fish, sh, dash, ksh, powershell, pwsh")
	fmt.Println()
	fmt.Println("  init [SHELL]          Print shell init command for eval")
	fmt.Println("                        Auto-detects shell if SHELL omitted")
	fmt.Println()
	fmt.Println("Usage:")
	fmt.Println("  # Add to shell profile for persistent completions")
	fmt.Printf("  %s --shell init >> ~/.bashrc      # bash\n", binaryName)
	fmt.Printf("  %s --shell init >> ~/.zshrc       # zsh\n", binaryName)
	fmt.Printf("  %s --shell init >> ~/.config/fish/config.fish  # fish\n", binaryName)
	fmt.Println()
	fmt.Println("  # Or eval directly for current session")
	fmt.Printf("  eval \"$(%s --shell init)\"\n", binaryName)
	fmt.Println()
	fmt.Println("  # Generate completion script only")
	fmt.Printf("  %s --shell completions bash > /etc/bash_completion.d/%s\n", binaryName, binaryName)
}

// detectShell auto-detects the current shell
func detectShell() string {
	// Check SHELL environment variable
	shell := os.Getenv("SHELL")
	if shell != "" {
		base := filepath.Base(shell)
		switch base {
		case "bash", "zsh", "fish", "sh", "dash", "ksh":
			return base
		}
	}

	// Check parent process name on Unix
	if ppid := os.Getppid(); ppid > 0 {
		if data, err := os.ReadFile(fmt.Sprintf("/proc/%d/comm", ppid)); err == nil {
			name := strings.TrimSpace(string(data))
			switch name {
			case "bash", "zsh", "fish", "sh", "dash", "ksh":
				return name
			}
		}
	}

	// Default to bash
	return "bash"
}

// printCompletions outputs shell completion script
func printCompletions(binaryName, shell string) {
	switch shell {
	case "bash":
		printBashCompletions(binaryName)
	case "zsh":
		printZshCompletions(binaryName)
	case "fish":
		printFishCompletions(binaryName)
	case "powershell", "pwsh":
		printPowerShellCompletions(binaryName)
	default:
		// Fallback to bash-compatible
		printBashCompletions(binaryName)
	}
}

// printInit outputs shell init command
func printInit(binaryName, shell string) {
	switch shell {
	case "bash":
		fmt.Printf("# %s shell completions\n", binaryName)
		fmt.Printf("eval \"$(%s --shell completions bash)\"\n", binaryName)
	case "zsh":
		fmt.Printf("# %s shell completions\n", binaryName)
		fmt.Printf("eval \"$(%s --shell completions zsh)\"\n", binaryName)
	case "fish":
		fmt.Printf("# %s shell completions\n", binaryName)
		fmt.Printf("%s --shell completions fish | source\n", binaryName)
	case "powershell", "pwsh":
		fmt.Printf("# %s shell completions\n", binaryName)
		fmt.Printf("Invoke-Expression (& %s --shell completions powershell)\n", binaryName)
	default:
		fmt.Printf("# %s shell completions\n", binaryName)
		fmt.Printf("eval \"$(%s --shell completions bash)\"\n", binaryName)
	}
}

// printBashCompletions outputs bash completion script
func printBashCompletions(binaryName string) {
	fmt.Printf(`# Bash completion for %s
# Generated by %s --shell completions bash

_%s_completions() {
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    # Main options
    opts="--help --version --status --mode --config --data --cache --log --backup --pid --address --port --daemon --debug --service --maintenance --update --shell"

    case "${prev}" in
        --mode)
            COMPREPLY=( $(compgen -W "production development" -- ${cur}) )
            return 0
            ;;
        --service)
            COMPREPLY=( $(compgen -W "start stop restart reload --install --uninstall --disable --help" -- ${cur}) )
            return 0
            ;;
        --maintenance)
            COMPREPLY=( $(compgen -W "backup restore update mode setup --help" -- ${cur}) )
            return 0
            ;;
        --update)
            COMPREPLY=( $(compgen -W "check yes branch --help" -- ${cur}) )
            return 0
            ;;
        --shell)
            COMPREPLY=( $(compgen -W "completions init --help" -- ${cur}) )
            return 0
            ;;
        --config|--data|--cache|--log|--backup)
            COMPREPLY=( $(compgen -d -- ${cur}) )
            return 0
            ;;
        --pid)
            COMPREPLY=( $(compgen -f -- ${cur}) )
            return 0
            ;;
        completions|init)
            COMPREPLY=( $(compgen -W "bash zsh fish powershell" -- ${cur}) )
            return 0
            ;;
        branch)
            COMPREPLY=( $(compgen -W "stable beta daily" -- ${cur}) )
            return 0
            ;;
    esac

    if [[ ${cur} == -* ]]; then
        COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )
        return 0
    fi
}

complete -F _%s_completions %s
`, binaryName, binaryName, binaryName, binaryName, binaryName)
}

// printZshCompletions outputs zsh completion script
func printZshCompletions(binaryName string) {
	fmt.Printf(`#compdef %s
# Zsh completion for %s
# Generated by %s --shell completions zsh

_%s() {
    local -a opts
    opts=(
        '--help[Show help message]'
        '-h[Show help message]'
        '--version[Show version information]'
        '-v[Show version information]'
        '--status[Show server status and health]'
        '--mode[Application mode]:mode:(production development)'
        '--config[Configuration directory]:directory:_files -/'
        '--data[Data directory]:directory:_files -/'
        '--cache[Cache directory]:directory:_files -/'
        '--log[Log directory]:directory:_files -/'
        '--backup[Backup directory]:directory:_files -/'
        '--pid[PID file path]:file:_files'
        '--address[Listen address]:address:'
        '--port[Server port (deprecated)]:port:'
        '--daemon[Daemonize]'
        '--debug[Enable debug mode]'
        '--service[Service management]:command:(start stop restart reload --install --uninstall --disable --help)'
        '--maintenance[Maintenance command]:command:(backup restore update mode setup --help)'
        '--update[Update command]:command:(check yes branch --help)'
        '--shell[Shell integration]:command:(completions init --help)'
    )
    _arguments -s $opts
}

_%s "$@"
`, binaryName, binaryName, binaryName, binaryName, binaryName)
}

// printFishCompletions outputs fish completion script
func printFishCompletions(binaryName string) {
	fmt.Printf(`# Fish completion for %s
# Generated by %s --shell completions fish

# Disable file completion by default
complete -c %s -f

# Main flags
complete -c %s -l help -s h -d 'Show help message'
complete -c %s -l version -s v -d 'Show version information'
complete -c %s -l status -d 'Show server status and health'
complete -c %s -l mode -d 'Application mode' -xa 'production development'
complete -c %s -l config -d 'Configuration directory' -xa '(__fish_complete_directories)'
complete -c %s -l data -d 'Data directory' -xa '(__fish_complete_directories)'
complete -c %s -l cache -d 'Cache directory' -xa '(__fish_complete_directories)'
complete -c %s -l log -d 'Log directory' -xa '(__fish_complete_directories)'
complete -c %s -l backup -d 'Backup directory' -xa '(__fish_complete_directories)'
complete -c %s -l pid -d 'PID file path' -xa '(__fish_complete_path)'
complete -c %s -l address -d 'Listen address'
complete -c %s -l port -d 'Server port (deprecated)'
complete -c %s -l daemon -d 'Daemonize'
complete -c %s -l debug -d 'Enable debug mode'
complete -c %s -l service -d 'Service management' -xa 'start stop restart reload --install --uninstall --disable --help'
complete -c %s -l maintenance -d 'Maintenance command' -xa 'backup restore update mode setup --help'
complete -c %s -l update -d 'Update command' -xa 'check yes branch --help'
complete -c %s -l shell -d 'Shell integration' -xa 'completions init --help'
`, binaryName, binaryName, binaryName, binaryName, binaryName, binaryName, binaryName,
		binaryName, binaryName, binaryName, binaryName, binaryName, binaryName, binaryName,
		binaryName, binaryName, binaryName, binaryName, binaryName, binaryName, binaryName)
}

// printPowerShellCompletions outputs PowerShell completion script
func printPowerShellCompletions(binaryName string) {
	fmt.Printf(`# PowerShell completion for %s
# Generated by %s --shell completions powershell

Register-ArgumentCompleter -Native -CommandName %s -ScriptBlock {
    param($wordToComplete, $commandAst, $cursorPosition)

    $commands = @(
        @{ Name = '--help'; Description = 'Show help message' }
        @{ Name = '-h'; Description = 'Show help message' }
        @{ Name = '--version'; Description = 'Show version information' }
        @{ Name = '-v'; Description = 'Show version information' }
        @{ Name = '--status'; Description = 'Show server status and health' }
        @{ Name = '--mode'; Description = 'Application mode' }
        @{ Name = '--config'; Description = 'Configuration directory' }
        @{ Name = '--data'; Description = 'Data directory' }
        @{ Name = '--cache'; Description = 'Cache directory' }
        @{ Name = '--log'; Description = 'Log directory' }
        @{ Name = '--backup'; Description = 'Backup directory' }
        @{ Name = '--pid'; Description = 'PID file path' }
        @{ Name = '--address'; Description = 'Listen address' }
        @{ Name = '--port'; Description = 'Server port (deprecated)' }
        @{ Name = '--daemon'; Description = 'Daemonize' }
        @{ Name = '--debug'; Description = 'Enable debug mode' }
        @{ Name = '--service'; Description = 'Service management' }
        @{ Name = '--maintenance'; Description = 'Maintenance command' }
        @{ Name = '--update'; Description = 'Update command' }
        @{ Name = '--shell'; Description = 'Shell integration' }
    )

    $commands | Where-Object { $_.Name -like "$wordToComplete*" } | ForEach-Object {
        [System.Management.Automation.CompletionResult]::new($_.Name, $_.Name, 'ParameterValue', $_.Description)
    }
}
`, binaryName, binaryName, binaryName)
}
