{{template "head" .}}
{{template "navbar" .}}

<!-- Main Content -->
<main class="container">
    <div class="admin-header">
        <div>
            <h1>‚è∞ Scheduled Tasks</h1>
            <p class="subtitle">Monitor and manage background scheduled tasks</p>
        </div>
        <button class="btn btn-secondary" onclick="loadTasks()">üîÑ Refresh</button>
    </div>

    <!-- Task Statistics -->
    <div class="stats-grid">
        <div class="stat-card">
            <div class="stat-icon">üìã</div>
            <div class="stat-content">
                <div class="stat-value" id="totalTasks">0</div>
                <div class="stat-label">Total Tasks</div>
            </div>
        </div>
        <div class="stat-card">
            <div class="stat-icon">‚úÖ</div>
            <div class="stat-content">
                <div class="stat-value" id="activeTasks">0</div>
                <div class="stat-label">Active</div>
            </div>
        </div>
        <div class="stat-card">
            <div class="stat-icon">‚ùå</div>
            <div class="stat-content">
                <div class="stat-value" id="failedTasks">0</div>
                <div class="stat-label">Failed</div>
            </div>
        </div>
        <div class="stat-card">
            <div class="stat-icon">üïê</div>
            <div class="stat-content">
                <div class="stat-value" id="last24hExecutions">0</div>
                <div class="stat-label">Last 24h Executions</div>
            </div>
        </div>
    </div>

    <!-- Tasks Table -->
    <div class="card">
        <div class="card-header">
            <h2>Scheduled Tasks</h2>
        </div>

        <div class="table-responsive">
            <table class="table">
                <thead>
                    <tr>
                        <th>Task Name</th>
                        <th>Schedule</th>
                        <th>Last Run</th>
                        <th>Next Run</th>
                        <th>Status</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="tasksTableBody">
                    <!-- Populated by JavaScript -->
                </tbody>
            </table>
        </div>
    </div>
</main>

<!-- Task Logs Modal -->
<div id="taskLogsModal" class="modal-overlay">
    <div class="modal modal-lg">
        <div class="modal-header">
            <h2 class="modal-title">üìã Task Logs: <span id="taskLogTitle"></span></h2>
            <button class="modal-close" onclick="Modal.close('taskLogsModal')">&times;</button>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="logLimit" class="form-label">Show Last</label>
                <select id="logLimit" class="form-select" onchange="loadTaskLogs()">
                    <option value="10">10 executions</option>
                    <option value="25" selected>25 executions</option>
                    <option value="50">50 executions</option>
                    <option value="100">100 executions</option>
                </select>
            </div>

            <div class="table-responsive">
                <table class="table">
                    <thead>
                        <tr>
                            <th>Execution Time</th>
                            <th>Status</th>
                            <th>Duration</th>
                            <th>Error Message</th>
                        </tr>
                    </thead>
                    <tbody id="taskLogsTableBody">
                        <!-- Populated by JavaScript -->
                    </tbody>
                </table>
            </div>
        </div>
        <div class="modal-footer">
            <button class="btn btn-secondary" onclick="Modal.close('taskLogsModal')">Close</button>
        </div>
    </div>
</div>

<!-- Scripts -->
<script src="/static/js/app.js"></script>
<script>
    let tasks = [];
    let currentTaskName = '';

    // Load tasks on page load
    document.addEventListener('DOMContentLoaded', function() {
        loadTasks();
        loadTaskStats();

        // Auto-refresh every 30 seconds
        setInterval(function() {
            loadTasks();
            loadTaskStats();
        }, 30000);

        // Initialize notifications if available
        if (typeof Notifications !== 'undefined') {
            Notifications.fetch();
            Notifications.startPolling(60000);
        }
    });

    // Load task statistics
    async function loadTaskStats() {
        try {
            const response = await fetch('/api/v1/admin/tasks/stats');
            if (!response.ok) {
                // If stats endpoint doesn't exist, calculate from tasks
                calculateStatsFromTasks();
                return;
            }

            const stats = await response.json();

            document.getElementById('totalTasks').textContent = stats.total || 0;
            document.getElementById('activeTasks').textContent = stats.active || 0;
            document.getElementById('failedTasks').textContent = stats.failed || 0;
            document.getElementById('last24hExecutions').textContent = stats.executions_24h || 0;
        } catch (error) {
            console.error('Error loading task stats:', error);
            // Calculate from tasks array if available
            if (tasks && tasks.length > 0) {
                calculateStatsFromTasks();
            }
        }
    }

    // Calculate statistics from tasks array
    function calculateStatsFromTasks() {
        if (!tasks || tasks.length === 0) return;

        const total = tasks.length;
        const active = tasks.filter(t => t.status === 'active' || t.status === 'running' || t.status === 'success').length;
        const failed = tasks.filter(t => t.status === 'failed' || t.status === 'error').length;

        // Count last 24h executions
        const yesterday = new Date();
        yesterday.setDate(yesterday.getDate() - 1);
        const executions24h = tasks.filter(t => {
            if (!t.last_run) return false;
            const lastRun = new Date(t.last_run);
            return lastRun >= yesterday;
        }).length;

        document.getElementById('totalTasks').textContent = total;
        document.getElementById('activeTasks').textContent = active;
        document.getElementById('failedTasks').textContent = failed;
        document.getElementById('last24hExecutions').textContent = executions24h;
    }

    // Load scheduled tasks
    async function loadTasks() {
        try {
            const response = await fetch('/api/v1/admin/tasks');
            if (!response.ok) throw new Error('Failed to load tasks');

            tasks = await response.json();
            renderTasks();
            calculateStatsFromTasks();
        } catch (error) {
            Toast.error('Failed to load tasks: ' + error.message);
            console.error('Error loading tasks:', error);
        }
    }

    // Render tasks table
    function renderTasks() {
        const tbody = document.getElementById('tasksTableBody');
        tbody.innerHTML = '';

        if (!tasks || tasks.length === 0) {
            tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; padding: 2rem;">No scheduled tasks found</td></tr>';
            return;
        }

        tasks.forEach(task => {
            const tr = document.createElement('tr');

            // Format last run with relative time
            let lastRunHtml = formatDateTime(task.last_run);

            // Format next run with countdown if available
            let nextRunHtml = formatDateTime(task.next_run);
            if (task.next_run && task.next_run !== '' && task.next_run !== null) {
                try {
                    const nextDate = new Date(task.next_run);
                    if (!isNaN(nextDate.getTime())) {
                        const now = new Date();
                        const diffMs = nextDate - now;
                        if (diffMs > 0) {
                            const diffMins = Math.floor(diffMs / 60000);
                            if (diffMins < 60) {
                                nextRunHtml = `<span style="color: var(--dracula-green);">in ${diffMins}m</span>`;
                            } else if (diffMins < 1440) {
                                nextRunHtml = `<span style="color: var(--dracula-cyan);">in ${Math.floor(diffMins/60)}h ${diffMins%60}m</span>`;
                            }
                        }
                    }
                } catch (e) {}
            }

            tr.innerHTML = `
                <td>
                    <strong style="color: var(--dracula-purple);">${escapeHtml(task.task_name || task.name || 'Unknown Task')}</strong>
                    ${task.description ? `<div style="font-size: 0.75rem; color: var(--dracula-comment); margin-top: 0.25rem;">${escapeHtml(task.description)}</div>` : ''}
                </td>
                <td><code style="font-size: 0.875rem;">${getScheduleText(task)}</code></td>
                <td>${lastRunHtml}</td>
                <td>${nextRunHtml}</td>
                <td><span class="badge ${getStatusBadge(task.status)}">${escapeHtml(task.status || 'pending')}</span></td>
                <td>
                    <button class="btn btn-sm btn-primary" onclick="viewTaskLogs('${escapeHtml(task.task_name || task.name)}')">
                        üìã Logs
                    </button>
                </td>
            `;
            tbody.appendChild(tr);
        });
    }

    // Get schedule text from task
    function getScheduleText(task) {
        if (task.schedule) {
            return escapeHtml(task.schedule);
        }
        if (task.cron) {
            return `<code>${escapeHtml(task.cron)}</code>`;
        }
        if (task.interval) {
            return formatInterval(task.interval);
        }
        return '-';
    }

    // Format interval in human readable format
    function formatInterval(seconds) {
        if (!seconds) return '-';

        if (seconds < 60) return `${seconds}s`;
        if (seconds < 3600) return `${Math.floor(seconds / 60)}m`;
        if (seconds < 86400) return `${Math.floor(seconds / 3600)}h`;
        return `${Math.floor(seconds / 86400)}d`;
    }

    // Get badge class for task status
    function getStatusBadge(status) {
        if (!status) return 'badge-secondary';
        const lower = status.toLowerCase();
        if (lower === 'success' || lower === 'completed' || lower === 'active') return 'badge-success';
        if (lower === 'running' || lower === 'in_progress') return 'badge-info';
        if (lower === 'failed' || lower === 'error') return 'badge-danger';
        if (lower === 'pending' || lower === 'scheduled') return 'badge-warning';
        return 'badge-secondary';
    }

    // Format date and time
    function formatDateTime(dateString) {
        if (!dateString || dateString === '' || dateString === null) {
            return '<span style="color: var(--dracula-comment); font-style: italic;">Never</span>';
        }
        try {
            const date = new Date(dateString);
            if (isNaN(date.getTime())) {
                return '<span style="color: var(--dracula-comment); font-style: italic;">Never</span>';
            }

            const now = new Date();
            const diff = Math.abs(now - date) / 1000; // difference in seconds

            // If less than 1 minute, show "just now"
            if (diff < 60) return 'Just now';

            // If less than 1 hour, show minutes
            if (diff < 3600) {
                const minutes = Math.floor(diff / 60);
                return `${minutes} minute${minutes !== 1 ? 's' : ''} ago`;
            }

            // If less than 24 hours, show hours
            if (diff < 86400) {
                const hours = Math.floor(diff / 3600);
                return `${hours} hour${hours !== 1 ? 's' : ''} ago`;
            }

            // Otherwise show full date
            return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
        } catch (e) {
            console.error('Error formatting date:', e);
            return '-';
        }
    }

    // View task logs
    async function viewTaskLogs(taskName) {
        currentTaskName = taskName;
        document.getElementById('taskLogTitle').textContent = taskName;
        Modal.open('taskLogsModal');
        await loadTaskLogs();
    }

    // Load task execution logs
    async function loadTaskLogs() {
        const limit = document.getElementById('logLimit').value;
        const tbody = document.getElementById('taskLogsTableBody');

        try {
            const params = new URLSearchParams({
                task: currentTaskName,
                limit: limit
            });

            const response = await fetch(`/api/v1/admin/tasks/logs?${params}`);
            if (!response.ok) throw new Error('Failed to load task logs');

            const logs = await response.json();
            tbody.innerHTML = '';

            if (!logs || logs.length === 0) {
                tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; padding: 2rem;">No execution logs found</td></tr>';
                return;
            }

            logs.forEach(log => {
                const tr = document.createElement('tr');
                const duration = log.duration ? `${log.duration}ms` : '-';

                tr.innerHTML = `
                    <td>${formatDateTime(log.executed_at || log.created_at)}</td>
                    <td><span class="badge ${getStatusBadge(log.status)}">${escapeHtml(log.status || 'unknown')}</span></td>
                    <td>${escapeHtml(duration)}</td>
                    <td>${log.error_message ? `<span class="text-error">${escapeHtml(log.error_message)}</span>` : '-'}</td>
                `;
                tbody.appendChild(tr);
            });
        } catch (error) {
            Toast.error('Failed to load task logs: ' + error.message);
            console.error('Error loading task logs:', error);
            tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; padding: 2rem; color: var(--dracula-red);">Error loading logs</td></tr>';
        }
    }

    // Escape HTML to prevent XSS
    function escapeHtml(text) {
        if (text === null || text === undefined) return '';
        const div = document.createElement('div');
        div.textContent = String(text);
        return div.innerHTML;
    }

    // Note: showConfirm is globally available from app.js
    // Uses custom modal instead of default confirm()
</script>

{{template "footer" .}}
